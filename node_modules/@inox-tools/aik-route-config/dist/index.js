import { defineIntegration, addVitePlugin, definePlugin, addIntegration } from 'astro-integration-kit';
import * as assert from 'assert';
import * as recast from 'recast';
import * as parser from 'recast/parsers/typescript.js';
import * as path from 'node:path';
import { Once } from '@inox-tools/utils/once';
import { fileURLToPath } from 'node:url';
import { normalizePath } from 'vite';
import { inspect } from 'node:util';
import debugC from 'debug';

// src/index.ts
var b = recast.types.builders;
function hoistGlobalPlugin(options) {
  const resolvedId = "\0" + options.configImport;
  return {
    name: `@inox-tools/aik-route-config/${options.configImport}`,
    resolveId(id) {
      if (id === options.configImport) {
        return resolvedId;
      }
    },
    load(id) {
      if (id === resolvedId) {
        return `
        export default function(context, cb) {
          globalThis[Symbol.for('@inox-tools/aik-route-config')]?.get('${options.configImport}')?.(context, cb);
        }`;
      }
    },
    transform(code, id) {
      if (id.endsWith(".astro")) {
        return hoistImport({
          logger: options.logger,
          magicImport: options.configImport,
          currentModule: id,
          code
        });
      }
    }
  };
}
function hoistImport({
  magicImport,
  currentModule,
  code,
  logger
}) {
  let ast;
  try {
    ast = recast.parse(code, {
      sourceFileName: currentModule,
      parser: {
        parse(_code) {
          return parser.parse(_code, {
            sourceType: "module",
            strictMode: false
          });
        }
      }
    });
  } catch (e) {
    logger.error(`Error on parsing: ${e}`);
    logger.error(`Code: ${code}`);
    throw e;
  }
  const visitor = makeVisitor(magicImport, currentModule, logger);
  recast.visit(ast, visitor);
  if (visitor.state.phase === "Cancelled" /* Cancelled */) return null;
  const newCode = recast.print(ast, { sourceFileName: currentModule, sourceMapName: "foo" });
  return {
    code: newCode.code,
    map: {
      mappings: newCode.map.mappings
    }
  };
}
function makeVisitor(magicImport, currentModule, logger) {
  return {
    state: {
      foundNames: [],
      phase: "Initializing" /* Initializing */
    },
    warnUnexpectedStructure(message) {
      logger.warn(`Detected Astro module with unexpected structure. Module "${currentModule}" ${message}.
Please send a report on https://github.com/Fryuni/inox-tools/issues/new with the module for reproduction`);
    },
    traverseWithState(state, path2) {
      const prevState = this.state.phase;
      this.state.phase = state;
      try {
        return this.traverse(path2);
      } finally {
        this.state.phase = prevState;
      }
    },
    visitImportDeclaration(path2) {
      if (this.state.phase !== "Initializing" /* Initializing */) return false;
      if (path2.node.source.type === "StringLiteral" && path2.node.source.value === magicImport) {
        const defaultSpecifier = path2.node.specifiers?.find(
          (specifier) => specifier.type === "ImportDefaultSpecifier"
        );
        const defaultImport = defaultSpecifier?.local?.name?.toString();
        if (defaultImport) {
          this.state.foundNames.push(defaultImport);
        }
      }
      return this.traverse(path2);
    },
    visitVariableDeclaration(path2) {
      if (this.state.astroNode === void 0 && path2.node.kind === "const") {
        const declaration = path2.node.declarations.find(
          (decl) => decl.type === "VariableDeclarator" && decl.id.type === "Identifier" && decl.id.name === "Astro" || decl.type === "VariableDeclarator" && decl.init?.type === "CallExpression" && decl.init.callee.type === "Identifier" && decl.init.callee.name === "$$createComponent"
        );
        if (declaration) {
          if (this.state.foundNames.length === 0) {
            this.state.phase = "Cancelled" /* Cancelled */;
            this.abort();
            return;
          }
          this.state.astroNode = path2;
          this.state.phase = "Initialized" /* Initialized */;
        }
      }
      this.traverse(path2);
    },
    visitCallExpression(path2) {
      if (path2.node.callee.type !== "Identifier") {
        this.traverse(path2);
        return;
      }
      if (path2.node.callee.name === "$$createComponent") {
        switch (this.state.phase) {
          case "Initializing" /* Initializing */:
          case "Initialized" /* Initialized */:
            this.traverseWithState("HoistingCalls" /* HoistingCalls */, path2);
            return;
          case "Cancelled" /* Cancelled */:
            assert.fail("Hoisting continued after abortion.");
          case "HoistingCalls" /* HoistingCalls */:
            this.warnUnexpectedStructure("has nested $$createComponent declarations");
            return false;
          case "EnrichingCallsInPlace" /* EnrichingCallsInPlace */:
          case "DroppingCalls" /* DroppingCalls */:
            this.warnUnexpectedStructure("has more than one $$createComponent declarations");
            return false;
        }
      }
      if (this.state.foundNames.includes(path2.node.callee.name)) {
        switch (this.state.phase) {
          case "HoistingCalls" /* HoistingCalls */:
          case "EnrichingCallsInPlace" /* EnrichingCallsInPlace */:
          case "Initialized" /* Initialized */: {
            path2.get("arguments").insertAt(
              0,
              b.objectExpression([
                b.objectProperty(
                  b.identifier("bundleFile"),
                  b.memberExpression(
                    b.memberExpression(b.identifier("import"), b.identifier("meta")),
                    b.identifier("url")
                  )
                ),
                b.objectProperty(b.identifier("sourceFile"), b.stringLiteral(currentModule))
              ])
            );
            this.traverseWithState("EnrichingCallsInPlace" /* EnrichingCallsInPlace */, path2);
            return;
          }
          case "DroppingCalls" /* DroppingCalls */: {
            return b.unaryExpression("void", b.numericLiteral(0));
          }
          default: {
            assert.fail("Unexpected phase for call expression");
          }
        }
      }
      this.traverse(path2);
    },
    visitFunctionDeclaration(path2) {
      switch (this.state.phase) {
        case "HoistingCalls" /* HoistingCalls */:
          this.traverseWithState("DroppingCalls" /* DroppingCalls */, path2);
          break;
        case "Initializing" /* Initializing */:
          this.state.phase = "Initialized" /* Initialized */;
        default:
          this.traverse(path2);
      }
    },
    visitExpressionStatement(path2) {
      this.traverse(path2);
      if (this.state.phase !== "HoistingCalls" /* HoistingCalls */) {
        return;
      }
      let expression = path2.node.expression;
      if (expression.type === "AwaitExpression" && expression.argument?.type === "CallExpression") {
        expression = expression.argument;
      }
      if (expression.type === "CallExpression" && expression.callee.type === "Identifier" && this.state.foundNames.includes(expression.callee.name)) {
        this.state.astroNode.insertBefore(b.expressionStatement(b.awaitExpression(expression)));
        path2.replace();
      }
    }
  };
}
var debug = debugC("inox-tools:aik-route-config");

// src/contextResolution.ts
function convertContext(context) {
  return componentToContextMapping.get(context.sourceFile) ?? null;
}
var componentToChunkMapping = /* @__PURE__ */ new Map();
var componentToContextMapping = /* @__PURE__ */ new Map();
var integration = defineIntegration({
  name: "@inox-tools/aik-route-config/context-resolution",
  setup: () => {
    let root;
    return {
      hooks: {
        "astro:config:setup": (params) => {
          const { config } = params;
          root = config.root;
          addVitePlugin(params, {
            plugin: {
              name: "@inox-tools/aik-route-config/context-resolution",
              async writeBundle(outputOptions, bundle) {
                const basePath = outputOptions.dir;
                for (const chunk of Object.values(bundle)) {
                  if (chunk.type !== "chunk") continue;
                  const fileName = path.join(basePath, chunk.fileName);
                  for (const id of chunk.moduleIds) {
                    if (id.endsWith(".astro")) {
                      componentToChunkMapping.set(id, fileName);
                    }
                  }
                }
              }
            }
          });
        },
        "astro:build:setup": ({ pages, target }) => {
          if (target !== "server") return;
          for (const { route } of pages.values()) {
            const fullComponentPath = normalizePath(fileURLToPath(new URL(route.component, root)));
            const context = componentToContextMapping.get(fullComponentPath);
            if (context) {
              context.route.push(route.route);
              context.routeData.push(route);
            } else {
              componentToContextMapping.set(fullComponentPath, {
                route: [route.route],
                routeData: [route],
                component: route.component
              });
            }
          }
        },
        "astro:build:ssr": async ({ logger, manifest: { routes } }) => {
          const ssrComponents = routes.map((r) => r.routeData).filter((r) => r.type === "page").map((r) => r.component).map((c) => fileURLToPath(new URL(c, root))).map((c) => componentToChunkMapping.get(c)).filter((m) => !!m);
          for (const module of ssrComponents) {
            await import(
              /* @vite-ignore */
              module
            ).catch((error) => {
              logger.error(`Failed to import SSR component: ${module} ${inspect(error)}`);
            });
          }
        }
      }
    };
  }
});
var integrateOnce = new Once();
function integrate(params) {
  integrateOnce.do(() => {
    debug("Injecting route-config integration");
    addIntegration(params, {
      integration: integration(),
      ensureUnique: true
    });
  });
}

// src/index.ts
var GLOBAL_HANDLERS_SYMBOL = Symbol.for("@inox-tools/aik-route-config");
var globalHandlers = globalThis[GLOBAL_HANDLERS_SYMBOL] ??= /* @__PURE__ */ new Map();
var src_default = definePlugin({
  name: "defineRouteConfig",
  setup: () => {
    return {
      "astro:config:setup": (params) => ({
        defineRouteConfig: (options) => {
          const { logger, command } = params;
          integrate(params);
          const innerHandler = async (context, value) => {
            if (command !== "build") return;
            debug(`Loading route config from ${context.sourceFile} from ${options.importName}`);
            const outerContext = convertContext(context);
            if (outerContext) {
              await options.callbackHandler(outerContext, value);
            } else {
              logger.warn(
                `Trying to set a route config for a file that is not a page: ${context.sourceFile}`
              );
            }
          };
          globalHandlers.set(options.importName, innerHandler);
          addVitePlugin(params, {
            plugin: hoistGlobalPlugin({
              configImport: options.importName,
              logger
            }),
            warnDuplicated: true
          });
        }
      })
    };
  }
});

export { src_default as default };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map