{"version":3,"sources":["../src/values.ts"],"names":["loadThunkValue","value","setNested","obj","prop","parts","current","idx","propName","next","path","setNestedIfNullish","key"],"mappings":"AAuCO,SAASA,CAAAA,CAAkBC,EAAyB,CAC1D,OAAO,OAAOA,CAAU,EAAA,UAAA,CAAaA,GAAUA,CAAAA,CAChD,CAkCO,SAASC,CAAAA,CACfC,EACAC,CACAH,CAAAA,CAAAA,CACO,CACP,GAAIE,CAAAA,EAAO,IAAM,CAAA,MAAM,IAAI,KAAA,CAAM,yBAAyB,CAC1D,CAAA,MAAME,EAAQD,CAAK,CAAA,KAAA,CAAM,GAAG,CAE5B,CAAA,IAAIE,EAAeH,CACnB,CAAA,IAAA,KAAW,CAACI,CAAKC,CAAAA,CAAQ,IAAKH,CAAM,CAAA,KAAA,CAAM,EAAG,CAAE,CAAA,CAAA,CAAE,OAAQ,EAAA,CAAG,CAC3D,MAAMI,EAAOH,CAAQE,CAAAA,CAAQ,EACvBE,CAAOL,CAAAA,CAAAA,CAAM,MAAM,CAAGE,CAAAA,CAAG,EAAE,IAAK,CAAA,GAAG,EAEzC,GAAIE,CAAAA,EAAQ,KAAM,CACjBH,CAAAA,CAAUA,EAAQE,CAAQ,CAAA,CAAI,EAAC,CAC/B,QACD,CAEA,GAAI,OAAOC,CAAAA,EAAS,SACnB,MAAM,IAAI,MAAM,CAA0B,uBAAA,EAAA,OAAOA,CAAI,CAAcC,WAAAA,EAAAA,CAAI,IAAI,CAE5EJ,CAAAA,CAAAA,CAAUG,EACX,CAEAH,CAAAA,CAAQD,EAAMA,CAAM,CAAA,MAAA,CAAS,CAAC,CAAC,CAAIJ,CAAAA,EACpC,CAKO,SAASU,CAAAA,CACfR,EACAC,CACAH,CAAAA,CAAAA,CACO,CACP,GAAIE,CAAAA,EAAO,KAAM,MAAM,IAAI,MAAM,yBAAyB,CAAA,CAC1D,MAAME,CAAQD,CAAAA,CAAAA,CAAK,MAAM,GAAG,CAAA,CAE5B,IAAIE,CAAAA,CAAeH,CACnB,CAAA,IAAA,KAAW,CAACI,CAAKC,CAAAA,CAAQ,IAAKH,CAAM,CAAA,KAAA,CAAM,EAAG,CAAE,CAAA,CAAA,CAAE,SAAW,CAAA,CAC3D,MAAMI,CAAOH,CAAAA,CAAAA,CAAQE,CAAQ,CACvBE,CAAAA,CAAAA,CAAOL,EAAM,KAAM,CAAA,CAAA,CAAGE,CAAG,CAAA,CAAE,IAAK,CAAA,GAAG,EAEzC,GAAIE,CAAAA,EAAQ,KAAM,CACjBH,CAAAA,CAAUA,EAAQE,CAAQ,CAAA,CAAI,EAC9B,CAAA,QACD,CAEA,GAAI,OAAOC,GAAS,QACnB,CAAA,MAAM,IAAI,KAAM,CAAA,CAAA,uBAAA,EAA0B,OAAOA,CAAI,CAAcC,WAAAA,EAAAA,CAAI,IAAI,CAE5EJ,CAAAA,CAAAA,CAAUG,EACX,CAEA,MAAMG,EAAMP,CAAMA,CAAAA,CAAAA,CAAM,OAAS,CAAC,CAAA,CAC9BC,EAAQM,CAAG,CAAA,EAAK,OACnBN,CAAQD,CAAAA,CAAAA,CAAMA,EAAM,MAAS,CAAA,CAAC,CAAC,CAAA,CAAIJ,CAErC,EAAA","file":"values.js","sourcesContent":["/**\n * A value that can be might be pending to be resolved.\n */\nexport type MaybePromise<T> = T | Promise<T>;\n\n/**\n * A value or a thunk for a value.\n *\n * A \"thunk\" is a function that takes no arguments and return\n * a value that is potentially expensive to compute.\n * This can be used when the value might not be needed and as\n * such can be computed on demand potentially saving the\n * expensive computation.\n *\n * If the value is not expensive to compute it can be used directly\n * for simplicity.\n *\n * A value type that is itself a function cannot be a \"maybe\" thunk.\n *\n * @see https://en.wikipedia.org/wiki/Thunk\n */\nexport type MaybeThunk<T> = T extends Function ? never : T | (() => T);\n\n/**\n * A value or a thunk for a synchronous or asynchronous value.\n *\n * @see MaybePromise\n * @see MaybeThunk\n */\nexport type MaybeAsyncThunk<T> = MaybeThunk<MaybePromise<T>>;\n\n/**\n * Load a value from a possibly thunk argument.\n *\n * If the value is a thunk it is called and the result is returned.\n * Otherwise the value itself is returned.\n *\n * @see MaybeThunk\n */\nexport function loadThunkValue<T>(value: MaybeThunk<T>): T {\n\treturn typeof value === 'function' ? value() : value;\n}\n\ntype NextDepth = [1, 2, 3, 4, 5, 6, 7];\n\n/**\n * Extract key-value entry pairs for each node in an object tree.\n */\nexport type NodeEntries<T, NoCircle = never, MaxDepth extends number = 0> = MaxDepth extends 7\n\t? never\n\t: T extends object\n\t\t? {\n\t\t\t\t[Key in keyof T & string]-?: T[Key] extends NoCircle\n\t\t\t\t\t? never\n\t\t\t\t\t: NodeEntries<T[Key], NoCircle | T[Key], NextDepth[MaxDepth]> extends infer Nested\n\t\t\t\t\t\t? Nested extends { key: string; value: unknown }\n\t\t\t\t\t\t\t? Nested['key'] extends ''\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tkey: Key;\n\t\t\t\t\t\t\t\t\t\tvalue: Nested['value'];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t\t\t| { key: Key; value: T[Key] }\n\t\t\t\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\t\t\t\tkey: `${Key}.${Nested['key']}`;\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: Nested['value'];\n\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t: never;\n\t\t\t}[keyof T & string]\n\t\t: { key: ''; value: T };\n\n/**\n * Sets a value nested in an object tree, creating the path as needed.\n */\nexport function setNested<T extends object, const P extends NodeEntries<T>['key']>(\n\tobj: T,\n\tprop: P,\n\tvalue: Extract<NodeEntries<T>, { key: P }>['value']\n): void {\n\tif (obj == null) throw new Error('Root object is nullish.');\n\tconst parts = prop.split('.');\n\n\tlet current: any = obj;\n\tfor (const [idx, propName] of parts.slice(0, -1).entries()) {\n\t\tconst next = current[propName];\n\t\tconst path = parts.slice(0, idx).join('.');\n\n\t\tif (next == null) {\n\t\t\tcurrent = current[propName] = {};\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (typeof next !== 'object')\n\t\t\tthrow new Error(`Cannot set property on ${typeof next} value at \"${path}\".`);\n\n\t\tcurrent = next;\n\t}\n\n\tcurrent[parts[parts.length - 1]] = value;\n}\n\n/**\n * Sets a value nested in an object tree, creating the path as needed, if it is not already set to a non-nullish value.\n */\nexport function setNestedIfNullish<T extends object, const P extends NodeEntries<T>['key']>(\n\tobj: T,\n\tprop: P,\n\tvalue: Extract<NodeEntries<T>, { key: P }>['value']\n): void {\n\tif (obj == null) throw new Error('Root object is nullish.');\n\tconst parts = prop.split('.');\n\n\tlet current: any = obj;\n\tfor (const [idx, propName] of parts.slice(0, -1).entries()) {\n\t\tconst next = current[propName];\n\t\tconst path = parts.slice(0, idx).join('.');\n\n\t\tif (next == null) {\n\t\t\tcurrent = current[propName] = {};\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (typeof next !== 'object')\n\t\t\tthrow new Error(`Cannot set property on ${typeof next} value at \"${path}\".`);\n\n\t\tcurrent = next;\n\t}\n\n\tconst key = parts[parts.length - 1];\n\tif (current[key] == null) {\n\t\tcurrent[parts[parts.length - 1]] = value;\n\t}\n}\n"]}