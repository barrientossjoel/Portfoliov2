/**
 * A value that can be might be pending to be resolved.
 */
type MaybePromise<T> = T | Promise<T>;
/**
 * A value or a thunk for a value.
 *
 * A "thunk" is a function that takes no arguments and return
 * a value that is potentially expensive to compute.
 * This can be used when the value might not be needed and as
 * such can be computed on demand potentially saving the
 * expensive computation.
 *
 * If the value is not expensive to compute it can be used directly
 * for simplicity.
 *
 * A value type that is itself a function cannot be a "maybe" thunk.
 *
 * @see https://en.wikipedia.org/wiki/Thunk
 */
type MaybeThunk<T> = T extends Function ? never : T | (() => T);
/**
 * A value or a thunk for a synchronous or asynchronous value.
 *
 * @see MaybePromise
 * @see MaybeThunk
 */
type MaybeAsyncThunk<T> = MaybeThunk<MaybePromise<T>>;
/**
 * Load a value from a possibly thunk argument.
 *
 * If the value is a thunk it is called and the result is returned.
 * Otherwise the value itself is returned.
 *
 * @see MaybeThunk
 */
declare function loadThunkValue<T>(value: MaybeThunk<T>): T;
type NextDepth = [1, 2, 3, 4, 5, 6, 7];
/**
 * Extract key-value entry pairs for each node in an object tree.
 */
type NodeEntries<T, NoCircle = never, MaxDepth extends number = 0> = MaxDepth extends 7 ? never : T extends object ? {
    [Key in keyof T & string]-?: T[Key] extends NoCircle ? never : NodeEntries<T[Key], NoCircle | T[Key], NextDepth[MaxDepth]> extends infer Nested ? Nested extends {
        key: string;
        value: unknown;
    } ? Nested['key'] extends '' ? {
        key: Key;
        value: Nested['value'];
    } : {
        key: Key;
        value: T[Key];
    } | {
        key: `${Key}.${Nested['key']}`;
        value: Nested['value'];
    } : never : never;
}[keyof T & string] : {
    key: '';
    value: T;
};
/**
 * Sets a value nested in an object tree, creating the path as needed.
 */
declare function setNested<T extends object, const P extends NodeEntries<T>['key']>(obj: T, prop: P, value: Extract<NodeEntries<T>, {
    key: P;
}>['value']): void;
/**
 * Sets a value nested in an object tree, creating the path as needed, if it is not already set to a non-nullish value.
 */
declare function setNestedIfNullish<T extends object, const P extends NodeEntries<T>['key']>(obj: T, prop: P, value: Extract<NodeEntries<T>, {
    key: P;
}>['value']): void;

export { type MaybeAsyncThunk, type MaybePromise, type MaybeThunk, type NodeEntries, loadThunkValue, setNested, setNestedIfNullish };
